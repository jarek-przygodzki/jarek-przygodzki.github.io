<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrency on Jarek Przygódzki&#39;s Blog</title>
    <link>https://jarekprzygodzki.dev/tags/concurrency/</link>
    <description>Recent content in concurrency on Jarek Przygódzki&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 21 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jarekprzygodzki.dev/tags/concurrency/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Converting Old Java Future To CompletableFuture Monadic Goodness</title>
      <link>https://jarekprzygodzki.dev/post/converting-old-java-future-to-completablefuture-monadic-goodness/</link>
      <pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jarekprzygodzki.dev/post/converting-old-java-future-to-completablefuture-monadic-goodness/</guid>
      <description>In 2004 Java 5 was released introducing a load of new features: generics, autoboxing, annotations, and… java.util.concurrent. You could use the exciting new java.util.concurrent.Future class to represent the result of an asynchronous computation, but it did not have any methods to combine these computations withoung blocking to get a result.
In Java 8, the CompletableFuture class was introduced to solve that problem. It allows to register callbacks to be executed once the computation is complete.</description>
    </item>
    
  </channel>
</rss>